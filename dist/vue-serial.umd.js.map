{"version":3,"file":"vue-serial.umd.js","sources":["../src/vue-serial.ts"],"sourcesContent":["/// <reference types=\"vite/client\" />\nimport { ref } from 'vue';\nimport type { Ref } from 'vue';\n\n// Default values\nconst default_baudRate = 115200;\nconst default_dataBits = 8;\nconst default_stopBits = 1;\nconst default_parity = \"none\";\nconst default_bufferSize = 255;\nconst default_flowControl = \"none\";\n\n// Ignore localStorage if not available\nconst localStorage = window.localStorage ?? {};\n\n// Declare VueSerial class\nexport default class VueSerial extends EventTarget {\n\n  /**\n   * Event which is triggered when data is received from the open device port.\n   * Call `serial.addEventListener(\"read\", ({ value }) => { ... })` to read incoming data.\n   * @event\n   */\n  static read: string;\n  \n  // Initialize private variables with their default values\n  #private = {\n    port: null as SerialPort|null,\n    reader: null as ReadableStreamDefaultReader<any>|null,\n    itv: null as ReturnType<typeof setTimeout> | null,\n    isPolling: false,\n    isOpen: ref(false),\n    isConnected: ref(false),\n    isClosing: ref(false),\n    usbVendorId: ref(undefined) as Ref<number | undefined>,\n    usbProductId: ref(undefined) as Ref<number | undefined>,\n    baudRate: ref(localStorage.VueSerial_baudRate ?? default_baudRate) as Ref<number>,\n    dataBits: ref(localStorage.VueSerial_dataBits ?? default_dataBits) as Ref<number>,\n    stopBits: ref(localStorage.VueSerial_stopBits ?? default_stopBits) as Ref<number>,\n    parity: ref(localStorage.VueSerial_parity ?? default_parity) as Ref<ParityType>,\n    bufferSize: ref(localStorage.VueSerial_bufferSize ?? default_bufferSize) as Ref<number>,\n    flowControl: ref(localStorage.VueSerial_flowControl ?? default_flowControl) as Ref<FlowControlType>,\n    dataCarrierDetect: ref(false),\n    clearToSend: ref(false),\n    ringIndicator: ref(false),\n    dataSetReady: ref(false),\n    dataTerminalReady: ref(false),\n    requestToSend: ref(false),\n    break: ref(false)\n  }\n\n  // Private asynchronous receiving function\n  async #start_receive () {\n    if(!this.#private.port) return;\n    while (this.#private.port.readable && this.#private.isClosing.value != true) {\n      this.#private.reader = this.#private.port.readable.getReader();\n      try {\n        while (true) {\n          const { value, done } = await this.#private.reader.read();\n          if (done) {\n            this.#private.reader.releaseLock(); // allow the serial port to be closed\n            break;\n          }\n          if(value) {\n            const event: any = new Event(\"read\");\n            event.value = value;\n            this.dispatchEvent(event);\n          }\n        }\n      } catch (error) { console.log(error); } // read error (parity error, device lost, etc.)\n    }\n  }\n\n  // Private port open function\n  async #open () {\n    if(this.#private.port) {\n      const info = this.#private.port.getInfo();\n      this.#private.usbVendorId.value = info.usbVendorId;\n      this.#private.usbProductId.value = info.usbProductId;\n      try {\n        await this.#private.port.open({\n          baudRate: this.#private.baudRate.value,\n          dataBits: this.#private.dataBits.value,\n          stopBits: this.#private.stopBits.value,\n          parity: this.#private.parity.value,\n          bufferSize: this.#private.bufferSize.value,\n          flowControl: this.#private.flowControl.value\n        });\n        // throws here if the serial port is already open in another window\n        this.#private.isOpen.value = true;\n        this.#private.isConnected.value = true;\n        this.#start_receive();\n      } catch (e) {\n        this.#private_reinitialize();\n        throw e;\n      }\n    }\n  }\n\n  // Private reset connection function\n  async #reconnect () {\n    if(!this.#private.port || this.#private.isClosing.value) return; // prevent concurrent close actions\n    this.#private.isClosing.value = true;\n    try {\n      if(this.#private.reader) await this.#private.reader.cancel();\n      if(this.#private.port) await this.#private.port.close();\n      this.#private.isClosing.value = false;\n      await this.#open();\n    } catch (e) {\n      this.#private_reinitialize();\n      this.stopSignalsPolling();\n      console.error(e);\n    }\n  }\n\n  // Private function for updating signals values\n  async #update_signals () {\n    if(!this.#private.port) throw new Error(\"Signals can't be retrieved as the port is closed\");\n    const signals = await this.#private.port.getSignals();\n    if(signals.clearToSend != this.#private.clearToSend.value) this.#private.clearToSend.value = signals.clearToSend;\n    if(signals.dataCarrierDetect != this.#private.dataCarrierDetect.value) this.#private.dataCarrierDetect.value = signals.dataCarrierDetect;\n    if(signals.dataSetReady != this.#private.dataSetReady.value) this.#private.dataSetReady.value = signals.dataSetReady;\n    if(signals.ringIndicator != this.#private.ringIndicator.value) this.#private.ringIndicator.value = signals.ringIndicator;\n    return signals;\n  }\n\n  // Private function for polling incoming signals periodically\n  async #signals_polling () {\n    if(this.#private.port) {\n      if(!this.#private.isPolling) { // cancel if the previous polling has not finished (if polling interval is too low)\n        this.#private.isPolling = true;\n        try {\n          await this.#update_signals();\n        } catch (e) { }\n        this.#private.isPolling = false;\n      }\n    }\n    else this.stopSignalsPolling();\n  }\n\n  // Private function to reinitialize variables after closing the port\n  #private_reinitialize () {\n    this.#private.isOpen.value = false;\n    this.#private.isConnected.value = false;\n    this.#private.isClosing.value = false;\n    this.#private.reader = null;\n    this.#private.port = null;\n    this.#private.dataCarrierDetect.value = false;\n    this.#private.clearToSend.value = false;\n    this.#private.ringIndicator.value = false;\n    this.#private.dataSetReady.value = false;\n    this.#private.dataTerminalReady.value = false;\n    this.#private.requestToSend.value = false;\n    this.#private.break.value = false;\n  }\n  \n  /**\n   * VueSerial instance constructor\n   */\n  constructor () {\n    super(); // initialize EventTarget functionality\n    if(!this.isAvailable) return; // return here if not available\n\n    // close connection on hot-reloading (during development), as the status variables are reset to their default values\n    import.meta?.hot?.on(\"vite:beforeUpdate\", () => this.close());\n\n    // bind event listener for device disconnection\n    navigator.serial?.addEventListener(\"disconnect\", (event) => {\n      if(event.target == this.#private.port) this.#private.isConnected.value = false;\n    });\n  }\n\n  /**\n   * Constant property indicating if the serial feature is available on the client navigator (Web Serial API is implemented and page is served using HTTPS)\n   * @readonly\n   */\n  get isAvailable () { return (navigator.serial && location.protocol == \"https:\"); }\n  set isAvailable (x) { throw new Error(\"isAvailable is readonly\"); }\n\n  /**\n   * Restore defaults settings\n   */\n  restoreDefaults () {\n    // these will also set localStorage values\n    this.baudRate = default_baudRate;\n    this.dataBits = default_dataBits;\n    this.stopBits = default_stopBits;\n    this.parity = default_parity;\n    this.bufferSize = default_bufferSize;\n    this.flowControl = default_flowControl;\n  }\n\n  /**\n   * Ask the user to select the serial port and open it\n   * @param filters - A list of objects containing vendor and product IDs used to search for attached devices.\n   */\n  async connect (filters: SerialPortFilter[] | undefined) {\n    let port = null;\n    // ask the user to select a port\n    try {\n      port = await navigator.serial.requestPort({ filters });\n      // throws here if no serial port was selected by the user\n    } catch (e) { }\n    // open the port with the current defined settings\n    if(port) {\n      if(this.#private.port) await this.close();\n      this.#private.port = port;\n      await this.#open();\n    }\n  }\n\n  /**\n   * Close the current port if open\n   */\n  async close () {\n    if(this.#private.isClosing.value) return; // prevent concurrent close actions\n    this.#private.isClosing.value = true;\n    try {\n      if(this.#private.reader) await this.#private.reader.cancel();\n      if(this.#private.port) {\n        await this.#private.port.close();\n        await this.#private.port.forget();\n      }\n    } catch (e) {\n      throw e;\n    } finally {\n      this.#private_reinitialize();\n      this.stopSignalsPolling();\n    }\n  }\n\n  /**\n   * Send data to the open serial port\n   * @param value - The content to send\n   */\n  async write (value: Iterable<number>) {\n    if(this.#private.port && this.#private.port.writable) {\n      if(typeof value == \"string\") {\n        const encoder = new TextEncoder();\n        value = encoder.encode(value);\n      }\n      const data = Uint8Array.from(value);\n      const writer = this.#private.port.writable.getWriter();\n      await writer.write(data);\n      writer.releaseLock();\n    }\n  }\n\n  /**\n   * Get the DCD, CTS, RI and DSR signals (alternative to use built-in polling)\n   * @returns Object containing \"dataCarrierDetect\", \"clearToSend\", \"ringIndicator\" and \"dataSetReady\" booleans\n   * @note You can also get the same values in serial.dataCarrierDetect, serial.clearToSend, serial.ringIndicator and serial.dataSetReady\n   */\n  async getSignals (): Promise<SerialInputSignals> {\n    return await this.#update_signals();\n  }\n\n  /**\n   * Set the DTR, RTS and break signals\n   * @param signals - object containing either \"dataTerminalReady\", \"requestToSend\" and/or \"break\" booleans\n   * @note You can also set the serial.dataTerminalReady, serial.requestToSend, and serial.break variables if you don't need asynchronous control\n   */\n  async setSignals (signals: SerialOutputSignals) {\n    if(this.#private.port) await this.#private.port.setSignals(signals);\n    if(\"dataTerminalReady\" in signals && !!signals.dataTerminalReady != this.#private.dataTerminalReady.value) this.#private.dataTerminalReady.value = !!signals.dataTerminalReady;\n    if(\"requestToSend\" in signals && !!signals.requestToSend != this.#private.requestToSend.value) this.#private.requestToSend.value = !!signals.requestToSend;\n    if(\"break\" in signals && !!signals.break != this.#private.break.value) this.#private.break.value = !!signals.break;\n  }\n\n  /**\n   * Start listening for signals changes and update the corresponding variables\n   * @param interval_ms - Polling interval in ms (100ms if not specified)\n   */\n  startSignalsPolling (interval_ms: number | null) {\n    if(this.#private.itv) clearInterval(this.#private.itv);\n    this.#private.itv = setInterval(() => this.#signals_polling(), interval_ms ?? 100);\n  }\n\n  /**\n   * Stop listening for signal changes\n   */\n  stopSignalsPolling () {\n    if(this.#private.itv) clearInterval(this.#private.itv);\n    this.#private.itv = null;\n  }\n\n  /**\n   * Tracks the active state of the serial port\n   * @readonly\n   */\n  get isOpen () { return this.#private.isOpen.value; }\n  set isOpen (x) { throw new Error(\"isOpen value is readonly\"); }\n\n  /**\n   * Becomes false if the open device has been disconnected\n   * @readonly\n   */\n  get isConnected () { return this.#private.isConnected.value; }\n  set isConnected (x) { throw new Error(\"isConnected value is readonly\"); }\n\n  /**\n   * Becomes true when the device is currently closing (after the close() function has been called)\n   * @readonly\n   */\n  get isClosing () { return this.#private.isClosing.value; }\n  set isClosing (x) { throw new Error(\"isClosing value is readonly\"); }\n\n  /**\n   * Current port USB vendor ID\n   * @readonly\n   */\n  get usbVendorId () { return this.#private.usbVendorId.value; }\n  set usbVendorId (x) { throw new Error(\"usbVendorId value is readonly\"); }\n\n  /**\n   * Current port USB product ID\n   * @readonly\n   */\n  get usbProductId () { return this.#private.usbProductId.value; }\n  set usbProductId (x) { throw new Error(\"usbProductId value is readonly\"); }\n\n  /**\n   * A positive, non-zero value indicating the baud rate at which serial communication should be established\n   */\n  get baudRate () { return this.#private.baudRate.value; }\n  set baudRate(value: number) {\n    const new_value = Math.floor(Number(value));\n    if(isNaN(new_value) || new_value <= 0) throw new Error(\"baudRate value must be a positive, non-zero value\");\n    if(new_value != this.#private.baudRate.value) {\n      this.#private.baudRate.value = new_value;\n      localStorage.VueSerial_baudRate = new_value;\n      if(this.#private.port) this.#reconnect();\n    }\n  }\n\n  /**\n   * The number of data bits per frame (either 7 or 8)\n   */\n  get dataBits () { return this.#private.dataBits.value; }\n  set dataBits(value) {\n    const new_value = (Math.floor(Number(value)) == 7) ? 7 : 8;\n    if(new_value != this.#private.dataBits.value) {\n      this.#private.dataBits.value = new_value;\n      localStorage.VueSerial_dataBits = new_value;\n      if(this.#private.port) this.#reconnect();\n    }\n  }\n\n  /**\n   * The number of stop bits per frame (either 1 or 2)\n   */\n  get stopBits () { return this.#private.stopBits.value; }\n  set stopBits (value) {\n    const new_value = (Math.floor(Number(value)) == 2) ? 2 : 1;\n    if(new_value != this.#private.stopBits.value) {\n      this.#private.stopBits.value = new_value;\n      localStorage.VueSerial_stopBits = new_value;\n      if(this.#private.port) this.#reconnect();\n    }\n  }\n\n  /**\n   * The parity mode (either \"none\", \"even\" or \"odd\")\n   */\n  get parity () { return this.#private.parity.value; }\n  set parity (value) {\n    const new_value = (value == \"even\") ? \"even\" : ((value == \"odd\") ? \"odd\" : \"none\");\n    if(new_value != this.#private.parity.value) {\n      this.#private.parity.value = new_value;\n      localStorage.VueSerial_parity = new_value;\n      if(this.#private.port) this.#reconnect();\n    }\n  }\n\n  /**\n   * A positive, non-zero value indicating the size of the read and write buffers that should be created.\n   */\n  get bufferSize () { return this.#private.bufferSize.value; }\n  set bufferSize (value) {\n    const new_value = Math.floor(Number(value));\n    if(isNaN(new_value) || new_value <= 0) throw new Error(\"bufferSize value must be a positive, non-zero value\");\n    if(new_value != this.#private.bufferSize.value) {\n      this.#private.bufferSize.value = new_value;\n      localStorage.VueSerial_bufferSize = new_value;\n      if(this.#private.port) this.#reconnect();\n    }\n  }\n\n  /**\n   * The flow control mode (either \"hardware\" or \"none\")\n   */\n  get flowControl () { return this.#private.flowControl.value; }\n  set flowControl (value) {\n    const new_value = (value == \"hardware\" ? \"hardware\" : \"none\");\n    if(new_value != this.#private.flowControl.value) {\n      this.#private.flowControl.value = new_value;\n      localStorage.VueSerial_flowControl = new_value;\n      if(this.#private.port) this.#reconnect();\n    }\n  }\n\n  /**\n   * Data Carrier Detect (DCD) input signal value\n   * @remarks This value must be refreshed manually by calling serial.getSignals() or automatically with serial.startSignalsPolling(...)\n   * @readonly\n   */\n  get dataCarrierDetect () { return this.#private.dataCarrierDetect.value; }\n  set dataCarrierDetect (x) { throw new Error(\"dataCarrierDetect value is readonly\"); }\n\n  /**\n   * Clear To Send (CTS) input signal value\n   * @remarks This value must be refreshed manually by calling serial.getSignals() or automatically with serial.startSignalsPolling(...)\n   * @readonly\n   */\n  get clearToSend () { return this.#private.clearToSend.value; }\n  set clearToSend (x) { throw new Error(\"clearToSend value is readonly\"); }\n\n  /**\n   * Ring Indicator (RI) input signal value\n   * @remarks This value must be refreshed manually by calling serial.getSignals() or automatically with serial.startSignalsPolling(...)\n   * @readonly\n   */\n  get ringIndicator () { return this.#private.ringIndicator.value; }\n  set ringIndicator (x) { throw new Error(\"ringIndicator value is readonly\"); }\n\n  /**\n   * Data Set Ready (DSR) input signal value\n   * @remarks This value must be refreshed manually by calling `serial.getSignals()` or automatically with serial.startSignalsPolling(...)\n   * @readonly\n   */\n  get dataSetReady () { return this.#private.dataSetReady.value; }\n  set dataSetReady (x) { throw new Error(\"dataSetReady value is readonly\"); }\n\n  /**\n   * Data Terminal Ready (DTR) output signal value\n   */\n  get dataTerminalReady () { return this.#private.dataTerminalReady.value; }\n  /**\n   * @remarks This will be set asynchronously. Prefer `await serial.setSignals({ dataTerminalReady: ... })` for precise asynchronous control\n   */\n  set dataTerminalReady (value) {\n    this.#private.dataTerminalReady.value = !!value;\n    if(this.#private.port) this.#private.port.setSignals({ dataTerminalReady: this.#private.dataTerminalReady.value });\n  }\n\n  /**\n   * Request To Send (RTS) output signal value\n   */\n  get requestToSend () { return this.#private.requestToSend.value; }\n  /**\n   * @remarks This will be set asynchronously. Prefer `await serial.setSignals({ requestToSend: ... })` for precise asynchronous control\n   */\n  set requestToSend (value) {\n    this.#private.requestToSend.value = !!value;\n    if(this.#private.port) this.#private.port.setSignals({ requestToSend: this.#private.requestToSend.value });\n  }\n\n  /**\n   * Break output signal value\n   */\n  get break () { return this.#private.break.value; }\n  /**\n   * @remarks This will be set asynchronously. Prefer `await serial.setSignals({ break: ... })` for precise asynchronous control\n   */\n  set break (value) {\n    this.#private.break.value = !!value;\n    if(this.#private.port) this.#private.port.setSignals({ break: this.#private.break.value });\n  }\n\n}"],"names":["default_parity","default_flowControl","localStorage","VueSerial","__privateAdd","_start_receive","_open","_reconnect","_update_signals","_signals_polling","_private_reinitialize","_private","ref","_a","event","__privateGet","x","filters","port","__privateMethod","open_fn","e","private_reinitialize_fn","value","data","writer","update_signals_fn","signals","interval_ms","signals_polling_fn","new_value","reconnect_fn","start_receive_fn","done","error","info","__publicField"],"mappings":"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"}