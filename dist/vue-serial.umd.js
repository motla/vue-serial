var V=Object.defineProperty;var z=(i,s,o)=>s in i?V(i,s,{enumerable:!0,configurable:!0,writable:!0,value:o}):i[s]=o;var _=(i,s,o)=>(z(i,typeof s!="symbol"?s+"":s,o),o),B=(i,s,o)=>{if(!s.has(i))throw TypeError("Cannot "+o)};var t=(i,s,o)=>(B(i,s,"read from private field"),o?o.call(i):s.get(i)),d=(i,s,o)=>{if(s.has(i))throw TypeError("Cannot add the same private member more than once");s instanceof WeakSet?s.add(i):s.set(i,o)};var l=(i,s,o)=>(B(i,s,"access private method"),o);(function(i,s){typeof exports=="object"&&typeof module<"u"?module.exports=s(require("vue")):typeof define=="function"&&define.amd?define(["vue"],s):(i=typeof globalThis<"u"?globalThis:i||self,i.VueSerial=s(i.Vue))})(this,function(i){var e,S,I,v,g,u,h,p,y,w,m,f,b;"use strict";const C="none",T="none",n=window.localStorage??{};class R extends EventTarget{constructor(){var a;super();d(this,S);d(this,v);d(this,u);d(this,p);d(this,w);d(this,f);d(this,e,{port:null,reader:null,itv:null,isPolling:!1,isOpen:i.ref(!1),isConnected:i.ref(!1),isClosing:i.ref(!1),usbVendorId:i.ref(void 0),usbProductId:i.ref(void 0),baudRate:i.ref(n.VueSerial_baudRate??115200),dataBits:i.ref(n.VueSerial_dataBits??8),stopBits:i.ref(n.VueSerial_stopBits??1),parity:i.ref(n.VueSerial_parity??C),bufferSize:i.ref(n.VueSerial_bufferSize??255),flowControl:i.ref(n.VueSerial_flowControl??T),dataCarrierDetect:i.ref(!1),clearToSend:i.ref(!1),ringIndicator:i.ref(!1),dataSetReady:i.ref(!1),dataTerminalReady:i.ref(!1),requestToSend:i.ref(!1),break:i.ref(!1)});this.isAvailable&&((a=navigator.serial)==null||a.addEventListener("disconnect",r=>{r.target==t(this,e).port&&(t(this,e).isConnected.value=!1)}))}get isAvailable(){return navigator.serial&&location.protocol=="https:"}set isAvailable(a){throw new Error("isAvailable is readonly")}restoreDefaults(){this.baudRate=115200,this.dataBits=8,this.stopBits=1,this.parity=C,this.bufferSize=255,this.flowControl=T}async connect(a){let r=null;try{r=await navigator.serial.requestPort({filters:a})}catch{}r&&(t(this,e).port&&await this.close(),t(this,e).port=r,await l(this,v,g).call(this))}async close(){if(!t(this,e).isClosing.value){t(this,e).isClosing.value=!0;try{t(this,e).reader&&await t(this,e).reader.cancel(),t(this,e).port&&(await t(this,e).port.close(),await t(this,e).port.forget())}catch(a){throw a}finally{l(this,f,b).call(this),this.stopSignalsPolling()}}}async write(a){if(t(this,e).port&&t(this,e).port.writable){typeof a=="string"&&(a=new TextEncoder().encode(a));const r=Uint8Array.from(a),c=t(this,e).port.writable.getWriter();await c.write(r),c.releaseLock()}}async getSignals(){return await l(this,p,y).call(this)}async setSignals(a){t(this,e).port&&await t(this,e).port.setSignals(a),"dataTerminalReady"in a&&!!a.dataTerminalReady!=t(this,e).dataTerminalReady.value&&(t(this,e).dataTerminalReady.value=!!a.dataTerminalReady),"requestToSend"in a&&!!a.requestToSend!=t(this,e).requestToSend.value&&(t(this,e).requestToSend.value=!!a.requestToSend),"break"in a&&!!a.break!=t(this,e).break.value&&(t(this,e).break.value=!!a.break)}startSignalsPolling(a){t(this,e).itv&&clearInterval(t(this,e).itv),t(this,e).itv=setInterval(()=>l(this,w,m).call(this),a??100)}stopSignalsPolling(){t(this,e).itv&&clearInterval(t(this,e).itv),t(this,e).itv=null}get isOpen(){return t(this,e).isOpen.value}set isOpen(a){throw new Error("isOpen value is readonly")}get isConnected(){return t(this,e).isConnected.value}set isConnected(a){throw new Error("isConnected value is readonly")}get isClosing(){return t(this,e).isClosing.value}set isClosing(a){throw new Error("isClosing value is readonly")}get usbVendorId(){return t(this,e).usbVendorId.value}set usbVendorId(a){throw new Error("usbVendorId value is readonly")}get usbProductId(){return t(this,e).usbProductId.value}set usbProductId(a){throw new Error("usbProductId value is readonly")}get baudRate(){return t(this,e).baudRate.value}set baudRate(a){const r=Math.floor(Number(a));if(isNaN(r)||r<=0)throw new Error("baudRate value must be a positive, non-zero value");r!=t(this,e).baudRate.value&&(t(this,e).baudRate.value=r,n.VueSerial_baudRate=r,t(this,e).port&&l(this,u,h).call(this))}get dataBits(){return t(this,e).dataBits.value}set dataBits(a){const r=Math.floor(Number(a))==7?7:8;r!=t(this,e).dataBits.value&&(t(this,e).dataBits.value=r,n.VueSerial_dataBits=r,t(this,e).port&&l(this,u,h).call(this))}get stopBits(){return t(this,e).stopBits.value}set stopBits(a){const r=Math.floor(Number(a))==2?2:1;r!=t(this,e).stopBits.value&&(t(this,e).stopBits.value=r,n.VueSerial_stopBits=r,t(this,e).port&&l(this,u,h).call(this))}get parity(){return t(this,e).parity.value}set parity(a){const r=a=="even"?"even":a=="odd"?"odd":"none";r!=t(this,e).parity.value&&(t(this,e).parity.value=r,n.VueSerial_parity=r,t(this,e).port&&l(this,u,h).call(this))}get bufferSize(){return t(this,e).bufferSize.value}set bufferSize(a){const r=Math.floor(Number(a));if(isNaN(r)||r<=0)throw new Error("bufferSize value must be a positive, non-zero value");r!=t(this,e).bufferSize.value&&(t(this,e).bufferSize.value=r,n.VueSerial_bufferSize=r,t(this,e).port&&l(this,u,h).call(this))}get flowControl(){return t(this,e).flowControl.value}set flowControl(a){const r=a=="hardware"?"hardware":"none";r!=t(this,e).flowControl.value&&(t(this,e).flowControl.value=r,n.VueSerial_flowControl=r,t(this,e).port&&l(this,u,h).call(this))}get dataCarrierDetect(){return t(this,e).dataCarrierDetect.value}set dataCarrierDetect(a){throw new Error("dataCarrierDetect value is readonly")}get clearToSend(){return t(this,e).clearToSend.value}set clearToSend(a){throw new Error("clearToSend value is readonly")}get ringIndicator(){return t(this,e).ringIndicator.value}set ringIndicator(a){throw new Error("ringIndicator value is readonly")}get dataSetReady(){return t(this,e).dataSetReady.value}set dataSetReady(a){throw new Error("dataSetReady value is readonly")}get dataTerminalReady(){return t(this,e).dataTerminalReady.value}set dataTerminalReady(a){t(this,e).dataTerminalReady.value=!!a,t(this,e).port&&t(this,e).port.setSignals({dataTerminalReady:t(this,e).dataTerminalReady.value})}get requestToSend(){return t(this,e).requestToSend.value}set requestToSend(a){t(this,e).requestToSend.value=!!a,t(this,e).port&&t(this,e).port.setSignals({requestToSend:t(this,e).requestToSend.value})}get break(){return t(this,e).break.value}set break(a){t(this,e).break.value=!!a,t(this,e).port&&t(this,e).port.setSignals({break:t(this,e).break.value})}}return e=new WeakMap,S=new WeakSet,I=async function(){if(t(this,e).port)for(;t(this,e).port.readable&&t(this,e).isClosing.value!=!0;){t(this,e).reader=t(this,e).port.readable.getReader();try{for(;;){const{value:a,done:r}=await t(this,e).reader.read();if(r){t(this,e).reader.releaseLock();break}if(a){const c=new Event("read");c.value=a,this.dispatchEvent(c)}}}catch(a){console.log(a)}}},v=new WeakSet,g=async function(){if(t(this,e).port){const a=t(this,e).port.getInfo();t(this,e).usbVendorId.value=a.usbVendorId,t(this,e).usbProductId.value=a.usbProductId;try{await t(this,e).port.open({baudRate:t(this,e).baudRate.value,dataBits:t(this,e).dataBits.value,stopBits:t(this,e).stopBits.value,parity:t(this,e).parity.value,bufferSize:t(this,e).bufferSize.value,flowControl:t(this,e).flowControl.value}),t(this,e).isOpen.value=!0,t(this,e).isConnected.value=!0,l(this,S,I).call(this)}catch(r){throw l(this,f,b).call(this),r}}},u=new WeakSet,h=async function(){if(!(!t(this,e).port||t(this,e).isClosing.value)){t(this,e).isClosing.value=!0;try{t(this,e).reader&&await t(this,e).reader.cancel(),t(this,e).port&&await t(this,e).port.close(),t(this,e).isClosing.value=!1,await l(this,v,g).call(this)}catch(a){l(this,f,b).call(this),this.stopSignalsPolling(),console.error(a)}}},p=new WeakSet,y=async function(){if(!t(this,e).port)throw new Error("Signals can't be retrieved as the port is closed");const a=await t(this,e).port.getSignals();return a.clearToSend!=t(this,e).clearToSend.value&&(t(this,e).clearToSend.value=a.clearToSend),a.dataCarrierDetect!=t(this,e).dataCarrierDetect.value&&(t(this,e).dataCarrierDetect.value=a.dataCarrierDetect),a.dataSetReady!=t(this,e).dataSetReady.value&&(t(this,e).dataSetReady.value=a.dataSetReady),a.ringIndicator!=t(this,e).ringIndicator.value&&(t(this,e).ringIndicator.value=a.ringIndicator),a},w=new WeakSet,m=async function(){if(t(this,e).port){if(!t(this,e).isPolling){t(this,e).isPolling=!0;try{await l(this,p,y).call(this)}catch{}t(this,e).isPolling=!1}}else this.stopSignalsPolling()},f=new WeakSet,b=function(){t(this,e).isOpen.value=!1,t(this,e).isConnected.value=!1,t(this,e).isClosing.value=!1,t(this,e).reader=null,t(this,e).port=null,t(this,e).dataCarrierDetect.value=!1,t(this,e).clearToSend.value=!1,t(this,e).ringIndicator.value=!1,t(this,e).dataSetReady.value=!1,t(this,e).dataTerminalReady.value=!1,t(this,e).requestToSend.value=!1,t(this,e).break.value=!1},_(R,"read"),R});
//# sourceMappingURL=vue-serial.umd.js.map
